{"version":3,"file":"bigint.utils.js","sourceRoot":"","sources":["../../ts/library/bigint.utils.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAA;AAE/B,MAAM,CAAC,MAAM,yBAAyB,GAAG,CAAC,MAAc,EAAE,QAAQ,GAAG,GAAG,EAAE,wBAAwB,GAAG,CAAC,EAAE,EAAE;IACzG,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAA;IAE/D,IAAI,gBAAgB,GAA6B,EAAE,WAAW,EAAE,KAAK,EAAE,qBAAqB,EAAE,CAAC,EAAE,CAAA;IAEjG,2DAA2D;IAC3D,IAAI,UAAU,GAAG,CAAC,KAAK,UAAU;QAAE,gBAAgB,CAAC,wBAAwB,GAAG,wBAAwB,CAAA;IAEvG,0EAA0E;IAC1E,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,GAAG,EAAE;QAChC,gBAAgB,GAAG,EAAE,qBAAqB,EAAE,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAA;KACpE;IAED,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAA;IAClE,MAAM,KAAK,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;IACjD,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAsC,CAAA;IAE9D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACzB,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE;YAC5B,2FAA2F;YAC3F,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;YAC7D,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;YAC/B,SAAQ;SACR;QACD,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;KACnC;IAED,OAAO,QAAQ,CAAA;AAChB,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,kCAAkC,GAAG,CAAC,MAAc,EAAE,QAAiB,EAAE,wBAAwB,GAAG,CAAC,EAAE,EAAE;IACrH,MAAM,WAAW,GAAG,yBAAyB,CAAC,MAAM,EAAE,QAAQ,EAAE,wBAAwB,CAAC,CAAA;IACzF,IAAI,YAAY,GAAG,EAAE,CAAA;IAErB,KAAK,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,WAAW;QAAE,YAAY,IAAI,KAAK,CAAA;IAE/D,OAAO,YAAY,CAAA;AACpB,CAAC,CAAA","sourcesContent":["import { ethers } from \"ethers\"\n\nexport const bigintToNumberFormatParts = (amount: bigint, decimals = 18n, maximumSignificantDigits = 4) => {\n\tconst floatValue = Number(ethers.formatUnits(amount, decimals))\n\n\tlet formatterOptions: Intl.NumberFormatOptions = { useGrouping: false, maximumFractionDigits: 3 }\n\n\t// maintain accuracy if value is a fraction of 1 ex 0.00001\n\tif (floatValue % 1 === floatValue) formatterOptions.maximumSignificantDigits = maximumSignificantDigits\n\n\t// apply only compacting with prefixes for values >= 10k or values <= -10k\n\tif (Math.abs(floatValue) >= 1e4) {\n\t\tformatterOptions = { minimumFractionDigits: 0, notation: 'compact' }\n\t}\n\n\tconst formatter = new Intl.NumberFormat('en-US', formatterOptions)\n\tconst parts = formatter.formatToParts(floatValue)\n\tconst partsMap = new Map<Intl.NumberFormatPartTypes, string>()\n\n\tfor (const part of parts) {\n\t\tif (part.type === 'compact') {\n\t\t\t// replace American format with Metric prefixes https://www.ibiblio.org/units/prefixes.html\n\t\t\tconst prefix = part.value.replace('K', 'k').replace('B', 'G')\n\t\t\tpartsMap.set(part.type, prefix)\n\t\t\tcontinue\n\t\t}\n\t\tpartsMap.set(part.type, part.value)\n\t}\n\n\treturn partsMap\n}\n\nexport const bigintToRoundedPrettyDecimalString = (amount: bigint, decimals?: bigint, maximumSignificantDigits = 4) => {\n\tconst numberParts = bigintToNumberFormatParts(amount, decimals, maximumSignificantDigits)\n\tlet numberString = ''\n\n\tfor (const [_type, value] of numberParts) numberString += value\n\n\treturn numberString\n}\n"]}