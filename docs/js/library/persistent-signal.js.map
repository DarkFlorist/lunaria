{"version":3,"file":"persistent-signal.js","sourceRoot":"","sources":["../../ts/library/persistent-signal.ts"],"names":[],"mappings":"AAAA,OAAO,EAAU,SAAS,EAAE,eAAe,EAAE,MAAM,iBAAiB,CAAA;AACpE,OAAO,KAAK,QAAQ,MAAM,UAAU,CAAA;AACpC,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAA;AACxC,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAA;AAE5C,MAAM,UAAU,mBAAmB,CAAkE,QAAgB,EAAE,aAAwB,EAAE,aAAgB,EAAE,OAAiB;IACnL,MAAM,YAAY,GAAG,OAAO,IAAI,YAAY,CAAA;IAC5C,MAAM,KAAK,GAAG,SAAS,CAAqB,SAAS,CAAC,CAAA;IAEtD,MAAM,iBAAiB,GAAG,GAAG,EAAE;QAC9B,MAAM,KAAK,GAAG,YAAY,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAA;QAE5C,IAAI,KAAK,EAAE;YACV,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;YACzE,aAAa,CAAC,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,EAAE,CAAA;SAC1E;IACF,CAAC,CAAA;IAED,MAAM,iBAAiB,GAAG,GAAG,EAAE;QAC9B,MAAM,eAAe,GAAG,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE,aAAa,CAAC,KAAK,CAAC,CAAA;QACrG,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE;YAC7B,KAAK,CAAC,KAAK,GAAG,eAAe,CAAC,OAAO,CAAA;YACrC,OAAM;SACN;QAED,YAAY,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,KAAK,CAAC,CAAA;QACrD,KAAK,CAAC,KAAK,GAAG,SAAS,CAAA;IACxB,CAAC,CAAA;IAED,SAAS,CAAC,iBAAiB,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAA;IACxC,eAAe,CAAC,iBAAiB,CAAC,CAAA;IAElC,OAAO,EAAE,KAAK,EAAE,CAAA;AACjB,CAAC","sourcesContent":["import { Signal, useSignal, useSignalEffect } from '@preact/signals'\nimport * as funtypes from 'funtypes'\nimport { useEffect } from 'preact/hooks'\nimport { safeSerialize } from '../schema.js'\n\nexport function persistSignalEffect<T extends funtypes.ParsedValue<funtypes.String, R>['config'], R>(cacheKey: string, derivedSignal: Signal<R>, funTypeParser: T, storage?: Storage) {\n\tconst cacheStorage = storage ?? localStorage\n\tconst error = useSignal<string | undefined>(undefined)\n\n\tconst syncCacheToSignal = () => {\n\t\tconst cache = cacheStorage.getItem(cacheKey)\n\n\t\tif (cache) {\n\t\t\tconst parsed = funtypes.String.withParser(funTypeParser).safeParse(cache)\n\t\t\tderivedSignal.value = parsed.success ? parsed.value : derivedSignal.peek()\n\t\t}\n\t}\n\n\tconst syncSignalToCache = () => {\n\t\tconst serializedStore = safeSerialize(funtypes.String.withParser(funTypeParser), derivedSignal.value)\n\t\tif (!serializedStore.success) {\n\t\t\terror.value = serializedStore.message\n\t\t\treturn\n\t\t}\n\n\t\tcacheStorage.setItem(cacheKey, serializedStore.value)\n\t\terror.value = undefined\n\t}\n\n\tuseEffect(syncCacheToSignal, [cacheKey])\n\tuseSignalEffect(syncSignalToCache)\n\n\treturn { error }\n}\n"]}