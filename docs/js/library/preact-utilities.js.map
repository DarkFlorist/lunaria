{"version":3,"file":"preact-utilities.js","sourceRoot":"","sources":["../../ts/library/preact-utilities.ts"],"names":[],"mappings":"AAAA,OAAO,EAAU,SAAS,EAAE,MAAM,iBAAiB,CAAA;AACnD,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;AAQhD,MAAM,UAAU,aAAa;IAC5B,SAAS,yBAAyB;QACjC,2FAA2F;QAC3F,OAAO,gBAAgB,CAAC,IAAI,EAAE,CAAC,MAAM,CAAA;QACrC,oFAAoF;QACpF,gBAAgB,CAAC,KAAK,GAAG,EAAE,MAAM,EAAE,CAAA;QACnC,OAAO,gBAAgB,CAAC,IAAI,EAAE,CAAA;IAC/B,CAAC;IAED,KAAK,UAAU,QAAQ,CAAC,QAA0B;QACjD,MAAM,OAAO,GAAG,yBAAyB,EAAE,CAAA;QAC3C,iHAAiH;QACjH,SAAS,iBAAiB,CAAC,SAA2B;YACrD,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAA;YAC7B,IAAI,MAAM,KAAK,SAAS;gBAAE,OAAM;YAChC,MAAM,CAAC,KAAK,GAAG,SAAS,CAAA;QACzB,CAAC;QACD,IAAI;YACH,MAAM,YAAY,GAAG,EAAE,KAAK,EAAE,SAAkB,EAAE,CAAA;YAClD,iBAAiB,CAAC,YAAY,CAAC,CAAA;YAC/B,MAAM,aAAa,GAAG,MAAM,QAAQ,EAAE,CAAA;YACtC,MAAM,aAAa,GAAG,EAAE,KAAK,EAAE,UAAmB,EAAE,KAAK,EAAE,aAAa,EAAE,CAAA;YAC1E,iBAAiB,CAAC,aAAa,CAAC,CAAA;SAChC;QAAC,OAAO,YAAqB,EAAE;YAC/B,MAAM,KAAK,GAAG,YAAY,YAAY,KAAK,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,4BAA4B,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CAAC,CAAA;YAC/L,MAAM,aAAa,GAAG,EAAE,KAAK,EAAE,UAAmB,EAAE,KAAK,EAAE,CAAA;YAC3D,iBAAiB,CAAC,aAAa,CAAC,CAAA;SAChC;IACF,CAAC;IAED,SAAS,KAAK;QACb,MAAM,MAAM,GAAG,yBAAyB,EAAE,CAAC,MAAM,CAAA;QACjD,IAAI,MAAM,KAAK,SAAS;YAAE,OAAM;QAChC,MAAM,CAAC,KAAK,GAAG,EAAE,KAAK,EAAE,UAAU,EAAE,CAAA;IACrC,CAAC;IAED,MAAM,MAAM,GAAG,SAAS,CAAmB,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,CAAA;IACjE,MAAM,gBAAgB,GAAG,SAAS,CAAwC,EAAE,CAAC,CAAA;IAE7E,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAA;AACzE,CAAC;AAED,sDAAsD;AACtD,sGAAsG;AACtG,MAAM,UAAU,YAAY,CAAI,KAAQ;IACvC,MAAM,MAAM,GAAG,SAAS,CAAI,KAAK,CAAC,CAAA;IAClC,MAAM,GAAG,GAAG,MAAM,CAAI,KAAK,CAAC,CAAA;IAE5B,SAAS,CAAC,GAAG,EAAE;QACd,MAAM,CAAC,KAAK,GAAG,GAAG,CAAC,OAAO,CAAA;IAC3B,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAA;IAEjB,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,CAAA;AACvB,CAAC","sourcesContent":["import { Signal, useSignal } from '@preact/signals'\nimport { useEffect, useRef } from 'preact/hooks'\nexport type Inactive = { state: 'inactive' }\nexport type Pending = { state: 'pending' }\nexport type Resolved<T> = { state: 'resolved'; value: T }\nexport type Rejected = { state: 'rejected'; error: Error }\nexport type AsyncProperty<T> = Inactive | Pending | Resolved<T> | Rejected\nexport type AsyncState<T> = { value: Signal<AsyncProperty<T>>; waitFor: (resolver: () => Promise<T>) => void; reset: () => void }\n\nexport function useAsyncState<T>(): AsyncState<T> {\n\tfunction getCaptureAndCancelOthers() {\n\t\t// delete previously captured signal so any pending async work will no-op when they resolve\n\t\tdelete captureContainer.peek().result\n\t\t// capture the signal in a new object so we can delete it later if it is interrupted\n\t\tcaptureContainer.value = { result }\n\t\treturn captureContainer.peek()\n\t}\n\n\tasync function activate(resolver: () => Promise<T>) {\n\t\tconst capture = getCaptureAndCancelOthers()\n\t\t// we need to read the property out of the capture every time we look at it, in case it is deleted asynchronously\n\t\tfunction setCapturedResult(newResult: AsyncProperty<T>) {\n\t\t\tconst result = capture.result\n\t\t\tif (result === undefined) return\n\t\t\tresult.value = newResult\n\t\t}\n\t\ttry {\n\t\t\tconst pendingState = { state: 'pending' as const }\n\t\t\tsetCapturedResult(pendingState)\n\t\t\tconst resolvedValue = await resolver()\n\t\t\tconst resolvedState = { state: 'resolved' as const, value: resolvedValue }\n\t\t\tsetCapturedResult(resolvedState)\n\t\t} catch (unknownError: unknown) {\n\t\t\tconst error = unknownError instanceof Error ? unknownError : typeof unknownError === 'string' ? new Error(unknownError) : new Error(`Unknown error occurred.\\n${JSON.stringify(unknownError)}`)\n\t\t\tconst rejectedState = { state: 'rejected' as const, error }\n\t\t\tsetCapturedResult(rejectedState)\n\t\t}\n\t}\n\n\tfunction reset() {\n\t\tconst result = getCaptureAndCancelOthers().result\n\t\tif (result === undefined) return\n\t\tresult.value = { state: 'inactive' }\n\t}\n\n\tconst result = useSignal<AsyncProperty<T>>({ state: 'inactive' })\n\tconst captureContainer = useSignal<{ result?: Signal<AsyncProperty<T>> }>({})\n\n\treturn { value: result, waitFor: resolver => activate(resolver), reset }\n}\n\n// Creates a signal-observable state of an element ref\n// enables listening to ref change from within a signal effect such as useSignalEffect and useComputed\nexport function useSignalRef<T>(value: T) {\n\tconst signal = useSignal<T>(value)\n\tconst ref = useRef<T>(value)\n\n\tuseEffect(() => {\n\t\tsignal.value = ref.current\n\t}, [ref.current])\n\n\treturn { ref, signal }\n}\n"]}